{"version":3,"sources":["dbhelper.js"],"names":["DBHelper","idb","open","upgradeDb","oldVersion","console","log","createObjectStore","keyPath","autoIncrement","restaurants","then","db","store","idbPromise","transaction","objectStore","Promise","all","map","restaurant","put","catch","error","tx","abort","createDatabase","getAll","reviews","review","id","index","fetch","DATABASE_URL","validateJSON","fetchLocalReviewsById","response","length","fetchReviewsByIdFromNetwork","addReviewsToDB","logError","ok","Error","statusText","json","defineRestaurants","fetchRestaurantsFromNetwork","addRestaurantsToDB","cuisine","neighborhood","fetchRestaurants","results","filter","r","cuisine_type","neighborhoods","i","v","indexOf","cuisines","status","url","method","uniqueCuisines","res","updateLocalFavouriteStatus","document","addEventListener","updateButtonState","e","target","dataset","action","saveButton","restaurantId","pressed","labelText","getAttribute","setAttribute","addFavoriteStatus","postReviewtoServer","submitPendingReviewtoDB","sendSyncRequest","navigator","serviceWorker","ready","reg","sync","register","options","complete","responses","clear","body","mapScript","createElement","src","appendChild","anchorID","mapElemID","anchor","getElementById","mapFrame","preventDefault","classList","toggle","google","maps","Marker","position","latlng","title","name","urlForRestaurant","animation","Animation","DROP"],"mappings":"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","file":"dbhelper.js","sourcesContent":["/**\r\n * Common database helper functions.\r\n */\r\n\r\nclass DBHelper {\r\n\r\n    /**\r\n     * Make an IndexedDB Database\r\n     */\r\n    static createDatabase() {\r\n        const idbPromise = idb.open('restaurants', 2, (upgradeDb) => {\r\n            switch (upgradeDb.oldVersion) {\r\n                case 0:\r\n                    // a placeholder case so that the switch block will\r\n                    // execute when the database is first created\r\n                    // (oldVersion is 0)\r\n                case 1:\r\n                    console.log('Creating the restaurants object store');\r\n                    let restaurantStore = upgradeDb.createObjectStore('restaurants', { keyPath: 'id' });\r\n\r\n                case 2:\r\n                    console.log('Creating the reviews object store');\r\n                    let reviewStore = upgradeDb.createObjectStore('reviews', { keyPath: 'id', autoIncrement: true });\r\n                    reviewStore.createIndex('restaurant_id', 'restaurant_id');\r\n\r\n\r\n                case 3:\r\n                    console.log('Creating the pending reviews object store');\r\n                    let pendingReviewStore = upgradeDb.createObjectStore('pending_reviews', { keyPath: 'id', autoIncrement: true});\r\n            }\r\n        })\r\n\r\n        return idbPromise;\r\n    }\r\n\r\n    /**\r\n     * Add restaurants to the database\r\n     */\r\n    static addRestaurantsToDB(restaurants) {\r\n        return DBHelper.createDatabase()\r\n            .then((db) => {\r\n                if (!db) {\r\n                    return;\r\n                }\r\n                const tx = db.transaction('restaurants', 'readwrite');\r\n                const store = tx.objectStore('restaurants');\r\n\r\n                return Promise.all(restaurants.map(restaurant => {\r\n                    console.log('adding restaurants to database');\r\n                    return store.put(restaurant);\r\n                }));\r\n            })\r\n            .catch((error) => {\r\n                tx.abort();\r\n                console.error(error);\r\n            });\r\n\r\n    }\r\n\r\n    /**\r\n     * Get all restaurants from the database\r\n     */\r\n    static fetchRestaurantsFromDB() {\r\n        return DBHelper.createDatabase()\r\n            .then((db) => {\r\n                const tx = db.transaction('restaurants', 'readonly');\r\n                const store = tx.objectStore('restaurants');\r\n                return store.getAll();\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Add reviews to the database\r\n     */\r\n    static addReviewsToDB(reviews) {\r\n        return DBHelper.createDatabase()\r\n            .then((db) => {\r\n                if (!db) {\r\n                    return;\r\n                }\r\n                const tx = db.transaction('reviews', 'readwrite');\r\n                const store = tx.objectStore('reviews');\r\n\r\n                return Promise.all(reviews.map(review => {\r\n                    console.log('adding reviews to database');\r\n                    return store.put(review);\r\n                }));\r\n\r\n            })\r\n            .catch((error) => {\r\n                tx.abort();\r\n                console.error(error);\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Fetch reviews from database\r\n     */\r\n    static fetchLocalReviewsById(id) {\r\n        console.log('fetchReviewsfromDB');\r\n        return DBHelper.createDatabase()\r\n            .then((db) => {\r\n                const tx = db.transaction('reviews', 'readonly');\r\n                const store = tx.objectStore('reviews');\r\n                const index = store.index('restaurant_id');\r\n                return index.getAll(id);\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Go to network to get reviews by restaurant id\r\n     */\r\n    static fetchReviewsByIdFromNetwork(id) {\r\n        console.log('fetch reviews from network');\r\n        return fetch(DBHelper.DATABASE_URL + `/reviews/?restaurant_id=${id}`)\r\n            .then(DBHelper.validateJSON)\r\n            .then(response => {\r\n                return response;\r\n            })\r\n\r\n    }\r\n\r\n    /**\r\n     * Fetch reviews from DB\r\n     * If no reviews, fetch from network\r\n     * add to database\r\n     */\r\n    static fetchReviewsById(id) {\r\n        return DBHelper.fetchLocalReviewsById(id)\r\n            .then(function(response) {\r\n\r\n                if (response.length === 0) {\r\n                    return DBHelper.fetchReviewsByIdFromNetwork(id)\r\n                        .then(response => {\r\n                            DBHelper.addReviewsToDB(response);\r\n                            return response;\r\n                        })\r\n                        .catch(DBHelper.logError);\r\n                    }\r\n\r\n                return response;\r\n\r\n            })\r\n    }\r\n\r\n\r\n    /**\r\n     * Update favourite status in client side database\r\n     */\r\n\r\n    static updateLocalFavouriteStatus(response) {\r\n        return DBHelper.createDatabase()\r\n            .then((db) => {\r\n                const tx = db.transaction('restaurants', 'readwrite');\r\n                const store = tx.objectStore('restaurants');\r\n                return store.put(response);\r\n            })\r\n    }\r\n\r\n    /**\r\n     * Database URL.\r\n     * Change this to restaurants.json file location on your server.\r\n     */\r\n\r\n    static get DATABASE_URL() {\r\n        const port = 1337; // Change this to your server port\r\n        return `http://localhost:${port}`;\r\n    }\r\n\r\n\r\n    static logError(error) {\r\n        console.error(error);\r\n    }\r\n\r\n    static validateJSON(response) {\r\n        if (!response.ok) {\r\n            throw Error(response.statusText);\r\n        }\r\n        return response.json();\r\n    }\r\n\r\n    static defineRestaurants(response) {\r\n        const restaurants = response;\r\n        console.log('Network contact');\r\n        return restaurants;\r\n    }\r\n\r\n    /**\r\n     * Go to network to get restaurants\r\n     */\r\n    static fetchRestaurantsFromNetwork() {\r\n        return fetch(DBHelper.DATABASE_URL + '/restaurants')\r\n            .then(DBHelper.validateJSON)\r\n            .then(DBHelper.defineRestaurants);\r\n    }\r\n\r\n    /**\r\n     * Fetch Restaurants without error handling\r\n     * Error Handling is in other functions\r\n     * Fetches restaurants from server\r\n     * Adds them to the database\r\n     * Returns dynamic request results\r\n     *\r\n     */\r\n\r\n    static fetchRestaurants() {\r\n        // First try to get results from Database\r\n        return DBHelper.fetchRestaurantsFromDB()\r\n            .then(function(response) {\r\n                // If the database is empty\r\n                // Go to the network\r\n                // Add network response to IndexedDB\r\n                if (response.length === 0) {\r\n                    return DBHelper.fetchRestaurantsFromNetwork()\r\n                        .then(response => {\r\n                            DBHelper.addRestaurantsToDB(response);\r\n                            return response;\r\n                        })\r\n                        .catch(DBHelper.logError);\r\n                }\r\n                return response;\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Fetch a restaurant by its ID.\r\n     * Error handling is in window.initMap()\r\n     */\r\n    static fetchRestaurantById(id) {\r\n        return fetch(DBHelper.DATABASE_URL + '/restaurants/' + id)\r\n            .then(DBHelper.validateJSON)\r\n            .then((response) => {\r\n                return response;\r\n            })\r\n    }\r\n\r\n    /**\r\n     * Fetch restaurants by a cuisine and a neighborhood\r\n     * Error handling is in updateRestaurants().\r\n     */\r\n    static fetchRestaurantByCuisineAndNeighborhood(cuisine, neighborhood) {\r\n        // Fetch all restaurants\r\n        return DBHelper.fetchRestaurants()\r\n            .then(restaurants => {\r\n                let results = restaurants;\r\n                if (cuisine != 'all') { // filter by cuisine\r\n                    results = results.filter(r => r.cuisine_type == cuisine);\r\n                }\r\n                if (neighborhood != 'all') { // filter by neighborhood\r\n                    results = results.filter(r => r.neighborhood == neighborhood);\r\n                }\r\n                return results;\r\n            })\r\n    }\r\n\r\n    /**\r\n     * Fetch all neighborhoods.\r\n     * Error handling is in fetchNeighboods().\r\n     */\r\n    static fetchNeighborhoods() {\r\n        // Fetch all restaurants\r\n        return DBHelper.fetchRestaurants()\r\n            .then(restaurants => {\r\n                // Get all neighborhoods from all restaurants\r\n                const neighborhoods = restaurants.map((v, i) => restaurants[i].neighborhood);\r\n                // Remove duplicates from neighborhoods\r\n                const uniqueNeighborhoods = neighborhoods.filter((v, i) => neighborhoods.indexOf(v) == i);\r\n                return uniqueNeighborhoods;\r\n            })\r\n    }\r\n\r\n    /**\r\n     * Fetch all cuisines with proper error handling.\r\n     * Error handling is in fetchCuisines().\r\n     */\r\n    static fetchCuisines() {\r\n        // Fetch all restaurants\r\n        return DBHelper.fetchRestaurants()\r\n            .then(restaurants => {\r\n                // Get all cuisines from all restaurants\r\n                const cuisines = restaurants.map((v, i) => restaurants[i].cuisine_type);\r\n                // Remove duplicates from cuisines\r\n                const uniqueCuisines = cuisines.filter((v, i) => cuisines.indexOf(v) == i);\r\n                return uniqueCuisines;\r\n            })\r\n    }\r\n\r\n    /**\r\n     * Restaurant page URL.\r\n     */\r\n    static urlForRestaurant(restaurant) {\r\n        return (`./restaurant.html?id=${restaurant.id}`);\r\n    }\r\n\r\n    /**\r\n     * Restaurant image URL.\r\n     */\r\n    static imageUrlForRestaurant(restaurant) {\r\n        return (`img/${restaurant.id}-600.jpg`);\r\n    }\r\n\r\n    /**\r\n     * Restaurant image srcset string.\r\n     */\r\n    static srcsetForRestaurant(restaurant) {\r\n        return (`img/webp/${restaurant.id}-400.webp 400w,\r\n      img/webp/${restaurant.id}-600.webp 600w,\r\n      img/webp/${restaurant.id}-800.webp 800w`);\r\n    }\r\n\r\n    /**\r\n     * Update favorite status.\r\n     */\r\n    static addFavoriteStatus(id, status) {\r\n        let url = (`http://localhost:1337/restaurants/${id}/?is_favorite=${status}`);\r\n\r\n        return fetch(url, {\r\n                method: 'PUT',\r\n            })\r\n            .then(DBHelper.validateJSON)\r\n            .then((res) => {\r\n                console.log('put request result', res);\r\n                DBHelper.updateLocalFavouriteStatus(res);\r\n\r\n            })\r\n            .catch(error => console.error('Error:', error))\r\n    }\r\n\r\n    /**\r\n     * Click handler to update favourite button aria labels.\r\n     */\r\n    static toggleButtonState() {\r\n        document.addEventListener('click', DBHelper.updateButtonState, false);\r\n    }\r\n\r\n    /**\r\n     * Toggles aria labels and aria pressed state\r\n     */\r\n    static updateButtonState(e) {\r\n        const Id = e.target.dataset.action;\r\n\r\n        if (!Id) {\r\n\r\n            return;\r\n\r\n        } else {\r\n\r\n            if (e.target.dataset.action === 'save') {\r\n                let saveButton = e.target;\r\n                let restaurantId = saveButton.dataset.restaurantId;\r\n                console.log(restaurantId);\r\n                let currentState = saveButton.getAttribute('aria-pressed');\r\n                let pressed = 'true';\r\n                let labelText = 'Remove from favourites';\r\n\r\n\r\n                if (currentState === 'true') {\r\n                    pressed = 'false';\r\n                    labelText = 'Add to favourites';\r\n                }\r\n\r\n                saveButton.setAttribute('aria-pressed', pressed);\r\n                saveButton.setAttribute('aria-label', labelText);\r\n\r\n                //post data about restaurant to Server and IndexedDB\r\n                DBHelper.addFavoriteStatus(restaurantId, pressed);\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update server with new review\r\n     * If offline, request background sync\r\n     * cache review locally\r\n     */\r\n    static submitReview(review) {\r\n        // if online submit review to server\r\n        DBHelper.postReviewtoServer(review)\r\n            .catch(() => {\r\n                console.log('submit review failed');\r\n                // if offline, send reviews to pending_reviews cache\r\n                DBHelper.submitPendingReviewtoDB(review);\r\n                DBHelper.sendSyncRequest(review);\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Register a sync event\r\n     */\r\n    static sendSyncRequest(review) {\r\n        if (navigator.serviceWorker) {\r\n            navigator.serviceWorker.ready\r\n                .then(reg => reg.sync.register('review-sync'))\r\n                .then(() => console.log('Sync event registered'));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Submit review to server\r\n     */\r\n    static postReviewtoServer(review) {\r\n        const url = 'http://localhost:1337/reviews/';\r\n        console.log(url);\r\n        console.log(review);\r\n        const options = {\r\n            method: 'POST',\r\n            body: JSON.stringify(review)\r\n        }\r\n\r\n        return fetch(url, options);\r\n    }\r\n\r\n\r\n    /**\r\n     * If offline, send review to pending_review object store\r\n     */\r\n    static submitPendingReviewtoDB(review) {\r\n        console.log('submit pending review to pending_reviews');\r\n        return DBHelper.createDatabase()\r\n            .then((db) => {\r\n                if (!db) {\r\n                    return;\r\n                }\r\n                const tx = db.transaction('pending_reviews', 'readwrite');\r\n                const store = tx.objectStore('pending_reviews');\r\n\r\n                console.log(review);\r\n                console.log('adding review to pending_reviews');\r\n\r\n                store.put(review);\r\n\r\n                return tx.complete;\r\n            })\r\n    }\r\n\r\n    /**\r\n     * Update local database with new review\r\n     */\r\n    static submitSingleReviewtoDB(review) {\r\n        return DBHelper.createDatabase()\r\n            .then((db) => {\r\n                const tx = db.transaction('reviews', 'readwrite');\r\n                const store = tx.objectStore('reviews');\r\n                return store.put(review);\r\n            })\r\n            .catch(DBHelper.logError);\r\n    }\r\n\r\n    /**\r\n     * Fetch reviews from local database\r\n     * to send to server\r\n     */\r\n    static fetchPendingReviewsFromDB() {\r\n        return DBHelper.createDatabase()\r\n            .then(db => {\r\n                if (!db) {\r\n                    return;\r\n                }\r\n                const tx = db.transaction('pending_reviews', 'readonly');\r\n                const store = tx.objectStore('pending_reviews');\r\n                return store.getAll();\r\n            })\r\n            .then(responses => {\r\n\r\n                const reviews = responses || [];\r\n\r\n                console.log('reading reviews from pending_reviews');\r\n                console.log(reviews);\r\n\r\n                return Promise.all(reviews.map(review => {\r\n                    console.log('post each review to server');\r\n                    return DBHelper.postReviewtoServer(review);\r\n\r\n                }));\r\n            })\r\n            .then(DBHelper.clearPendingReviews)\r\n            .catch(error => console.log(error));\r\n    }\r\n\r\n    /**\r\n     * Clear pending reviews from local database\r\n     */\r\n    static clearPendingReviews() {\r\n        return DBHelper.createDatabase()\r\n            .then(db => {\r\n                if (!db) {\r\n                    return;\r\n                }\r\n                const tx = db.transaction('pending_reviews', 'readwrite');\r\n                const store = tx.objectStore('pending_reviews');\r\n                store.clear();\r\n                console.log('pending review store cleared');\r\n                return tx.complete;\r\n\r\n            })\r\n\r\n    }\r\n\r\n\r\n    /**\r\n     * Add map script to html\r\n     */\r\n    static addScript() {\r\n        const target = document.body;\r\n        const mapScript = document.createElement('script');\r\n        mapScript.src = 'https://maps.googleapis.com/maps/api/js?key=AIzaSyCSQXjgi1K6hqDS4W3nWVK_z0lntlbLFPo&libraries=places&callback=initMap';\r\n        target.appendChild(mapScript);\r\n    }\r\n\r\n    static toggleMap(anchorID, mapElemID) {\r\n        const anchor = document.getElementById(anchorID);\r\n        const mapFrame = document.getElementById(mapElemID);\r\n\r\n        anchor.addEventListener('click', (e) => {\r\n            // Prevent Default link behaviour\r\n            e.preventDefault();\r\n\r\n            // Check for map section\r\n            if (!mapFrame) return;\r\n\r\n            // Toggle map section visiblity\r\n            mapFrame.classList.toggle('is-visible');\r\n\r\n            // Fetch script only if it hasn't already been fetched\r\n            if (!window.google) {\r\n                DBHelper.addScript();\r\n            }\r\n\r\n        }, false);\r\n\r\n    }\r\n\r\n    /**\r\n     * Map marker for a restaurant.\r\n     */\r\n    static mapMarkerForRestaurant(restaurant, map) {\r\n        const marker = new google.maps.Marker({\r\n            position: restaurant.latlng,\r\n            title: restaurant.name,\r\n            url: DBHelper.urlForRestaurant(restaurant),\r\n            map: map,\r\n            animation: google.maps.Animation.DROP\r\n        });\r\n        return marker;\r\n    }\r\n\r\n}"]}