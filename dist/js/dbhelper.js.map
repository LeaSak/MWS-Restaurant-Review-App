{"version":3,"sources":["dbhelper.js"],"names":["DBHelper","console","idb","open","upgradeDb","oldVersion","log","createObjectStore","keyPath","restaurants","createDatabase","idbPromise","db","transaction","objectStore","Promise","all","map","restaurant","store","put","catch","error","tx","abort","then","getAll","reviews","review","response","ok","Error","statusText","json","fetch","DATABASE_URL","defineRestaurants","fetchRestaurantsFromDB","length","fetchRestaurantsFromNetwork","addRestaurantsToDB","logError","id","fetchReviewsFromDB","fetchReviewsByIdFromNetwork","addReviewsToDB","cuisine","neighborhood","fetchRestaurants","results","filter","r","cuisine_type","neighborhoods","v","i","indexOf","cuisines","uniqueNeighborhoods","url","status","uniqueCuisines","method","res","updateLocalFavouriteStatus","document","addEventListener","updateButtonState","e","target","dataset","action","saveButton","restaurantId","pressed","labelText","getAttribute","setAttribute","postReviewtoServer","sendSyncRequest","navigator","serviceWorker","submitReviewtoDB","ready","reg","sync","register","options","body","JSON","stringify","responses","clearPendingReviews","clear","mapScript","src","appendChild","anchorID","mapElemID","anchor","getElementById","mapFrame","preventDefault","classList","toggle","window","addScript","google","maps","Marker","position","latlng","title","name","urlForRestaurant","animation","Animation","DROP"],"mappings":"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","file":"dbhelper.js","sourcesContent":["/**\r\n * Common database helper functions.\r\n */\r\n\r\nclass DBHelper {\r\n\r\n    /**\r\n     * Make an IndexedDB Database\r\n     */\r\n    static createDatabase() {\r\n        const idbPromise = idb.open('restaurants', 2, (upgradeDb) => {\r\n            switch (upgradeDb.oldVersion) {\r\n                case 0:\r\n                    // a placeholder case so that the switch block will\r\n                    // execute when the database is first created\r\n                    // (oldVersion is 0)\r\n                case 1:\r\n                    console.log('Creating the restaurants object store');\r\n                    upgradeDb.createObjectStore('restaurants', { keyPath: 'id' });\r\n\r\n                case 2:\r\n                    console.log('Creating the reviews object store');\r\n                    upgradeDb.createObjectStore('reviews', { keyPath: 'id' });\r\n\r\n                case 3:\r\n                    console.log('Creating the pending reviews object store');\r\n                    upgradeDb.createObjectStore('pending_reviews', { keyPath: 'id'});\r\n            }\r\n        })\r\n\r\n        return idbPromise;\r\n    }\r\n\r\n    /**\r\n     * Add restaurants to the database\r\n     */\r\n    static addRestaurantsToDB(restaurants) {\r\n        return DBHelper.createDatabase()\r\n            .then((db) => {\r\n                if (!db) {\r\n                    return;\r\n                }\r\n                const tx = db.transaction('restaurants', 'readwrite');\r\n                const store = tx.objectStore('restaurants');\r\n\r\n                return Promise.all(restaurants.map(restaurant => {\r\n                    console.log('adding restaurants to database');\r\n                    return store.put(restaurant);\r\n                }));\r\n            })\r\n            .catch((error) => {\r\n                tx.abort();\r\n                console.error(error);\r\n            });\r\n\r\n    }\r\n\r\n    /**\r\n     * Get all restaurants from the database\r\n     */\r\n    static fetchRestaurantsFromDB() {\r\n        return DBHelper.createDatabase()\r\n            .then((db) => {\r\n                const tx = db.transaction('restaurants', 'readonly');\r\n                const store = tx.objectStore('restaurants');\r\n                return store.getAll();\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Add reviews to the database\r\n     */\r\n    static addReviewsToDB(reviews) {\r\n        return DBHelper.createDatabase()\r\n            .then((db) => {\r\n                if (!db) {\r\n                    return;\r\n                }\r\n                const tx = db.transaction('reviews', 'readwrite');\r\n                const store = tx.objectStore('reviews');\r\n\r\n                return Promise.all(reviews.map(review => {\r\n                    console.log('adding reviews to database');\r\n                    return store.put(review);\r\n                }));\r\n\r\n            })\r\n            .catch((error) => {\r\n                tx.abort();\r\n                console.error(error);\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Fetch reviews from database\r\n     */\r\n    static fetchReviewsFromDB() {\r\n        return DBHelper.createDatabase()\r\n            .then((db) => {\r\n                const tx = db.transaction('reviews', 'readonly');\r\n                const store = tx.objectStore('reviews');\r\n                return store.getAll();\r\n            });\r\n    }\r\n\r\n\r\n    /**\r\n     * Update favourite status in client side database\r\n     */\r\n\r\n    static updateLocalFavouriteStatus(response){\r\n        return DBHelper.createDatabase()\r\n            .then((db) => {\r\n                const tx = db.transaction('restaurants', 'readwrite');\r\n                const store = tx.objectStore('restaurants');\r\n                return store.put(response);\r\n            })\r\n    }\r\n\r\n    /**\r\n     * Database URL.\r\n     * Change this to restaurants.json file location on your server.\r\n     */\r\n\r\n    static get DATABASE_URL() {\r\n        const port = 1337; // Change this to your server port\r\n        return `http://localhost:${port}`;\r\n    }\r\n\r\n\r\n    static logError(error) {\r\n        console.error(error);\r\n    }\r\n\r\n    static validateJSON(response) {\r\n        if (!response.ok) {\r\n            throw Error(response.statusText);\r\n        }\r\n        return response.json();\r\n    }\r\n\r\n    static defineRestaurants(response) {\r\n        const restaurants = response;\r\n        console.log('Network contact');\r\n        return restaurants;\r\n    }\r\n\r\n    /**\r\n     * Go to network to get restaurants\r\n     */\r\n    static fetchRestaurantsFromNetwork() {\r\n        return fetch(DBHelper.DATABASE_URL + '/restaurants')\r\n            .then(DBHelper.validateJSON)\r\n            .then(DBHelper.defineRestaurants);\r\n    }\r\n\r\n    /**\r\n     * Fetch Restaurants without error handling\r\n     * Error Handling is in other functions\r\n     * Fetches restaurants from server\r\n     * Adds them to the database\r\n     * Returns dynamic request results\r\n     *\r\n     */\r\n\r\n    static fetchRestaurants() {\r\n        // First try to get results from Database\r\n        return DBHelper.fetchRestaurantsFromDB()\r\n            .then(function(response) {\r\n                // If the database is empty\r\n                // Go to the network\r\n                // Add network response to IndexedDB\r\n                if (response.length === 0) {\r\n                    return DBHelper.fetchRestaurantsFromNetwork()\r\n                        .then(response => {\r\n                            DBHelper.addRestaurantsToDB(response);\r\n                            return response;\r\n                        })\r\n                        .catch(DBHelper.logError);\r\n                }\r\n                return response;\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Go to network to get reviews\r\n     */\r\n    static fetchReviewsByIdFromNetwork(id) {\r\n        return fetch(DBHelper.DATABASE_URL + `/reviews/?restaurant_id=${id}`)\r\n            .then(DBHelper.validateJSON)\r\n            .then(response => {\r\n                return response;\r\n            })\r\n\r\n    }\r\n\r\n    /**\r\n     * Fetch reviews from DB\r\n     * If no reviews, fetch from network\r\n     * add to database\r\n     */\r\n    static fetchReviewsById(id) {\r\n        return DBHelper.fetchReviewsFromDB()\r\n            .then(function(response) {\r\n                if (response.length === 0) {\r\n                    return DBHelper.fetchReviewsByIdFromNetwork(id)\r\n                        .then(response => {\r\n                            DBHelper.addReviewsToDB(response);\r\n                            return response;\r\n                        })\r\n                        .catch(DBHelper.logError);\r\n                }\r\n                return response;\r\n            })\r\n    }\r\n\r\n    /**\r\n     * Fetch a restaurant by its ID.\r\n     * Error handling is in window.initMap()\r\n     */\r\n    static fetchRestaurantById(id) {\r\n        return fetch(DBHelper.DATABASE_URL + '/restaurants/' + id)\r\n            .then(DBHelper.validateJSON)\r\n            .then((response) => {\r\n                return response;\r\n            })\r\n    }\r\n\r\n    /**\r\n     * Fetch restaurants by a cuisine and a neighborhood\r\n     * Error handling is in updateRestaurants().\r\n     */\r\n    static fetchRestaurantByCuisineAndNeighborhood(cuisine, neighborhood) {\r\n        // Fetch all restaurants\r\n        return DBHelper.fetchRestaurants()\r\n            .then(restaurants => {\r\n                let results = restaurants;\r\n                if (cuisine != 'all') { // filter by cuisine\r\n                    results = results.filter(r => r.cuisine_type == cuisine);\r\n                }\r\n                if (neighborhood != 'all') { // filter by neighborhood\r\n                    results = results.filter(r => r.neighborhood == neighborhood);\r\n                }\r\n                return results;\r\n            })\r\n    }\r\n\r\n    /**\r\n     * Fetch all neighborhoods.\r\n     * Error handling is in fetchNeighboods().\r\n     */\r\n    static fetchNeighborhoods() {\r\n        // Fetch all restaurants\r\n        return DBHelper.fetchRestaurants()\r\n            .then(restaurants => {\r\n                // Get all neighborhoods from all restaurants\r\n                const neighborhoods = restaurants.map((v, i) => restaurants[i].neighborhood);\r\n                // Remove duplicates from neighborhoods\r\n                const uniqueNeighborhoods = neighborhoods.filter((v, i) => neighborhoods.indexOf(v) == i);\r\n                return uniqueNeighborhoods;\r\n            })\r\n    }\r\n\r\n    /**\r\n     * Fetch all cuisines with proper error handling.\r\n     * Error handling is in fetchCuisines().\r\n     */\r\n    static fetchCuisines() {\r\n        // Fetch all restaurants\r\n        return DBHelper.fetchRestaurants()\r\n            .then(restaurants => {\r\n                // Get all cuisines from all restaurants\r\n                const cuisines = restaurants.map((v, i) => restaurants[i].cuisine_type);\r\n                // Remove duplicates from cuisines\r\n                const uniqueCuisines = cuisines.filter((v, i) => cuisines.indexOf(v) == i);\r\n                return uniqueCuisines;\r\n            })\r\n    }\r\n\r\n    /**\r\n     * Restaurant page URL.\r\n     */\r\n    static urlForRestaurant(restaurant) {\r\n        return (`./restaurant.html?id=${restaurant.id}`);\r\n    }\r\n\r\n    /**\r\n     * Restaurant image URL.\r\n     */\r\n    static imageUrlForRestaurant(restaurant) {\r\n        return (`img/${restaurant.id}-600.jpg`);\r\n    }\r\n\r\n    /**\r\n     * Restaurant image srcset string.\r\n     */\r\n    static srcsetForRestaurant(restaurant) {\r\n        return (`img/webp/${restaurant.id}-400.webp 400w,\r\n      img/webp/${restaurant.id}-600.webp 600w,\r\n      img/webp/${restaurant.id}-800.webp 800w`);\r\n    }\r\n\r\n    /**\r\n     * Update favorite status.\r\n     */\r\n    static addFavoriteStatus(id, status) {\r\n        let url = (`http://localhost:1337/restaurants/${id}/?is_favorite=${status}`);\r\n\r\n        return fetch(url, {\r\n                method: 'PUT',\r\n            })\r\n            .then(DBHelper.validateJSON)\r\n            .then((res) => {\r\n                console.log('put request result', res);\r\n                DBHelper.updateLocalFavouriteStatus(res);\r\n\r\n            })\r\n            .catch(error => console.error('Error:', error))\r\n    }\r\n\r\n    /**\r\n     * Click handler to update favourite button aria labels.\r\n     */\r\n    static toggleButtonState() {\r\n        document.addEventListener('click', DBHelper.updateButtonState, false);\r\n    }\r\n\r\n    /**\r\n     * Toggles aria labels and aria pressed state\r\n     */\r\n    static updateButtonState(e) {\r\n        const Id = e.target.dataset.action;\r\n\r\n        if (!Id) {\r\n\r\n            return;\r\n\r\n        } else {\r\n\r\n            if (e.target.dataset.action === 'save') {\r\n                let saveButton = e.target;\r\n                let restaurantId = saveButton.dataset.restaurantId;\r\n                console.log(restaurantId);\r\n                let currentState = saveButton.getAttribute('aria-pressed');\r\n                let pressed = 'true';\r\n                let labelText = 'Remove from favourites';\r\n\r\n\r\n                if (currentState === 'true') {\r\n                    pressed = 'false';\r\n                    labelText = 'Add to favourites';\r\n                }\r\n\r\n                saveButton.setAttribute('aria-pressed', pressed);\r\n                saveButton.setAttribute('aria-label', labelText);\r\n\r\n                //post data about restaurant to Server and IndexedDB\r\n                DBHelper.addFavoriteStatus(restaurantId, pressed);\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    //submit review to server/database\r\n    static submitPendingReview(review){\r\n        DBHelper.postReviewtoServer(review)\r\n        .catch(() => {\r\n            DBHelper.sendSyncRequest(review);\r\n        });\r\n    }\r\n\r\n    // register a sync event\r\n    static sendSyncRequest(review){\r\n        if(navigator.serviceWorker){\r\n            console.log('send sync request');\r\n            DBHelper.submitReviewtoDB(review);\r\n            navigator.serviceWorker.ready\r\n            .then(reg => reg.sync.register('review-sync'));\r\n        }\r\n    }\r\n\r\n    // submit review to server\r\n    static postReviewtoServer(review) {\r\n        const url = DBHelper.DATABASE_URL + '/reviews';\r\n        const options = {\r\n            method: 'POST',\r\n            body: JSON.stringify(review)\r\n        }\r\n\r\n        return fetch(url, options)\r\n    }\r\n\r\n\r\n    // submit pending review to database\r\n    static submitReviewtoDB(review){\r\n        return DBHelper.createDatabase()\r\n            .then((db) => {\r\n                if (!db) {\r\n                    return;\r\n                }\r\n                const tx = db.transaction('pending_reviews', 'readwrite');\r\n                const store = tx.objectStore('pending_reviews');\r\n\r\n                store.put(review);\r\n\r\n                return review;\r\n            })\r\n    }\r\n\r\n    // fetch and clear pending reviews from database\r\n    static fetchPendingReviewsFromDB(){\r\n        return DBHelper.createDatabase()\r\n        .then(db => {\r\n            if (!db) {\r\n                    return;\r\n                }\r\n                const tx = db.transaction('pending_reviews', 'readonly');\r\n                const store = tx.objectStore('pending_reviews');\r\n                return store.getAll();\r\n        })\r\n        .then(responses => {\r\n\r\n            const reviews = responses || [];\r\n\r\n            return Promise.all(reviews.map(review => {\r\n                console.log('post each review to server');\r\n                return DBHelper.postReviewtoServer(review);\r\n\r\n            }));\r\n        })\r\n        .then(DBHelper.clearPendingReviews)\r\n        .catch(error => console.log(error));\r\n    }\r\n\r\n    // clear pending reviews from database\r\n    static clearPendingReviews(){\r\n        return DBHelper.createDatabase()\r\n        .then(db => {\r\n            if (!db) {\r\n                    return;\r\n                }\r\n                const tx = db.transaction('pending_reviews', 'readwrite');\r\n                const store = tx.objectStore('pending_reviews');\r\n                store.clear();\r\n                console.log('pending review store cleared');\r\n                return tx.complete;\r\n\r\n        })\r\n\r\n    }\r\n\r\n\r\n    /**\r\n     * Add map script to html\r\n     */\r\n    static addScript() {\r\n        const target = document.body;\r\n        const mapScript = document.createElement('script');\r\n        mapScript.src = 'https://maps.googleapis.com/maps/api/js?key=AIzaSyCSQXjgi1K6hqDS4W3nWVK_z0lntlbLFPo&libraries=places&callback=initMap';\r\n        target.appendChild(mapScript);\r\n    }\r\n\r\n    static toggleMap(anchorID, mapElemID) {\r\n        const anchor = document.getElementById(anchorID);\r\n        const mapFrame = document.getElementById(mapElemID);\r\n\r\n        anchor.addEventListener('click', (e) => {\r\n            // Prevent Default link behaviour\r\n            e.preventDefault();\r\n\r\n            // Check for map section\r\n            if (!mapFrame) return;\r\n\r\n            // Toggle map section visiblity\r\n            mapFrame.classList.toggle('is-visible');\r\n\r\n            // Fetch script only if it hasn't already been fetched\r\n            if (!window.google) {\r\n                DBHelper.addScript();\r\n            }\r\n\r\n        }, false);\r\n\r\n    }\r\n\r\n    /**\r\n     * Map marker for a restaurant.\r\n     */\r\n    static mapMarkerForRestaurant(restaurant, map) {\r\n        const marker = new google.maps.Marker({\r\n            position: restaurant.latlng,\r\n            title: restaurant.name,\r\n            url: DBHelper.urlForRestaurant(restaurant),\r\n            map: map,\r\n            animation: google.maps.Animation.DROP\r\n        });\r\n        return marker;\r\n    }\r\n\r\n}"]}