{"version":3,"sources":["dbhelper.js"],"names":["DBHelper","error","console","response","Error","statusText","json","restaurants","log","idb","open","upgradeDb","oldVersion","createObjectStore","keyPath","restaurantStore","autoIncrement","createIndex","reviewStore","createDatabase","then","db","store","transaction","objectStore","tx","map","restaurant","put","catch","abort","fetch","DATABASE_URL","validateJSON","defineRestaurants","fetchRestaurantsFromDB","length","addRestaurantsToDB","fetchRestaurantsFromNetwork","id","cuisine","neighborhood","fetchRestaurants","results","filter","r","cuisine_type","neighborhoods","v","i","indexOf","cuisines","uniqueNeighborhoods","uniqueCuisines","review","postReviewtoServer","submitPendingReviewtoDB","sendSyncRequest","reviews","Promise","all","index","getAll","fetchLocalReviewsById","fetchReviewsByIdFromNetwork","logError","sync_tag","navigator","reg","sync","register","url","options","method","body","JSON","stringify","serviceWorker","complete","responses","clearPendingReviews","clear","pressed","fetchFavouriteStatusLocally","is_favorite","addFavoriteStatusLocally","get","parseInt","status","res","selectedRestaurant","addPendingHeartStatus","retryPostHeartStatus","clearPendingHearts","document","updateButtonState","action","e","target","saveButton","restaurantId","dataset","getAttribute","labelText","setAttribute","updateFavoriteStatusLocally","addEventListener","mapScript","createElement","src","appendChild","anchorID","mapFrame","currentState","anchor","preventDefault","google","maps","Marker","position","latlng","title","name","Animation","DROP"],"mappings":"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","file":"dbhelper.js","sourcesContent":["/**\r\n * Common database helper functions.\r\n */\r\n\r\nclass DBHelper {\r\n\r\n    /***** HELPERS *****/\r\n\r\n    /**\r\n     * Database URL.\r\n     * Change this to restaurants.json file location on your server.\r\n     */\r\n\r\n    static get DATABASE_URL() {\r\n        const port = 1337; // Change this to your server port\r\n        return `http://localhost:${port}`;\r\n    }\r\n\r\n\r\n    static logError(error) {\r\n        console.error(error);\r\n    }\r\n\r\n    static validateJSON(response) {\r\n        if (!response.ok) {\r\n            throw Error(response.statusText);\r\n        }\r\n        return response.json();\r\n    }\r\n\r\n    static defineRestaurants(response) {\r\n        const restaurants = response;\r\n        console.log('Network contact');\r\n        return restaurants;\r\n    }\r\n\r\n    /***** DATABASE *****/\r\n\r\n    /**\r\n     * Make an IndexedDB Database\r\n     */\r\n    static createDatabase() {\r\n        const idbPromise = idb.open('restaurants', 2, (upgradeDb) => {\r\n            switch (upgradeDb.oldVersion) {\r\n                case 0:\r\n                    // a placeholder case so that the switch block will\r\n                    // execute when the database is first created\r\n                    // (oldVersion is 0)\r\n                case 1:\r\n                    console.log('Creating the restaurants object store');\r\n                    let restaurantStore = upgradeDb.createObjectStore('restaurants', { keyPath: 'id' });\r\n\r\n                case 2:\r\n                    console.log('Creating the reviews object store');\r\n                    let reviewStore = upgradeDb.createObjectStore('reviews', { keyPath: 'id', autoIncrement: true });\r\n                    reviewStore.createIndex('restaurant_id', 'restaurant_id');\r\n\r\n\r\n                case 3:\r\n                    console.log('Creating the pending reviews object store');\r\n                    let pendingReviewStore = upgradeDb.createObjectStore('pending_reviews', { keyPath: 'id', autoIncrement: true });\r\n\r\n                case 4:\r\n                    console.log('Creating the pending favourite status object store');\r\n                    let pendingHeartStore = upgradeDb.createObjectStore('pending_heart', { keyPath: 'id', autoIncrement: true });\r\n\r\n            }\r\n        })\r\n\r\n        return idbPromise;\r\n    }\r\n\r\n\r\n    /***** RESTAURANTS *****/\r\n\r\n    /**\r\n     * Add restaurants to the database\r\n     */\r\n    static addRestaurantsToDB(restaurants) {\r\n        return DBHelper.createDatabase()\r\n            .then((db) => {\r\n                if (!db) {\r\n                    return;\r\n                }\r\n                const tx = db.transaction('restaurants', 'readwrite');\r\n                const store = tx.objectStore('restaurants');\r\n\r\n                return Promise.all(restaurants.map(restaurant => {\r\n                    console.log('adding restaurants to database');\r\n                    return store.put(restaurant);\r\n                }));\r\n            })\r\n            .catch((error) => {\r\n                tx.abort();\r\n                console.error(error);\r\n            });\r\n\r\n    }\r\n\r\n    /**\r\n     * Get all restaurants from the database\r\n     */\r\n    static fetchRestaurantsFromDB() {\r\n        return DBHelper.createDatabase()\r\n            .then((db) => {\r\n                const tx = db.transaction('restaurants', 'readonly');\r\n                const store = tx.objectStore('restaurants');\r\n                return store.getAll();\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Go to network to get restaurants\r\n     */\r\n    static fetchRestaurantsFromNetwork() {\r\n        return fetch(DBHelper.DATABASE_URL + '/restaurants')\r\n            .then(DBHelper.validateJSON)\r\n            .then(DBHelper.defineRestaurants);\r\n    }\r\n\r\n    /**\r\n     * Fetch Restaurants without error handling\r\n     * Error Handling is in other functions\r\n     * Fetches restaurants from server\r\n     * Adds them to the database\r\n     * Returns dynamic request results\r\n     *\r\n     */\r\n\r\n    static fetchRestaurants() {\r\n        // First try to get results from Database\r\n        return DBHelper.fetchRestaurantsFromDB()\r\n            .then(function(response) {\r\n                // If the database is empty\r\n                // Go to the network\r\n                // Add network response to IndexedDB\r\n                if (response.length === 0) {\r\n                    return DBHelper.fetchRestaurantsFromNetwork()\r\n                        .then(response => {\r\n                            DBHelper.addRestaurantsToDB(response);\r\n                            return response;\r\n                        })\r\n                        .catch(DBHelper.logError);\r\n                }\r\n                return response;\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Fetch a restaurant by its ID.\r\n     * Error handling is in window.initMap()\r\n     */\r\n    static fetchRestaurantById(id) {\r\n        return fetch(DBHelper.DATABASE_URL + '/restaurants/' + id)\r\n            .then(DBHelper.validateJSON)\r\n            .then((response) => {\r\n                return response;\r\n            })\r\n    }\r\n\r\n    /**\r\n     * Fetch restaurants by a cuisine and a neighborhood\r\n     * Error handling is in updateRestaurants().\r\n     */\r\n    static fetchRestaurantByCuisineAndNeighborhood(cuisine, neighborhood) {\r\n        // Fetch all restaurants\r\n        return DBHelper.fetchRestaurants()\r\n            .then(restaurants => {\r\n                let results = restaurants;\r\n                if (cuisine != 'all') { // filter by cuisine\r\n                    results = results.filter(r => r.cuisine_type == cuisine);\r\n                }\r\n                if (neighborhood != 'all') { // filter by neighborhood\r\n                    results = results.filter(r => r.neighborhood == neighborhood);\r\n                }\r\n                return results;\r\n            })\r\n    }\r\n\r\n    /**\r\n     * Fetch all neighborhoods.\r\n     * Error handling is in fetchNeighboods().\r\n     */\r\n    static fetchNeighborhoods() {\r\n        // Fetch all restaurants\r\n        return DBHelper.fetchRestaurants()\r\n            .then(restaurants => {\r\n                // Get all neighborhoods from all restaurants\r\n                const neighborhoods = restaurants.map((v, i) => restaurants[i].neighborhood);\r\n                // Remove duplicates from neighborhoods\r\n                const uniqueNeighborhoods = neighborhoods.filter((v, i) => neighborhoods.indexOf(v) == i);\r\n                return uniqueNeighborhoods;\r\n            })\r\n    }\r\n\r\n    /**\r\n     * Fetch all cuisines with proper error handling.\r\n     * Error handling is in fetchCuisines().\r\n     */\r\n    static fetchCuisines() {\r\n        // Fetch all restaurants\r\n        return DBHelper.fetchRestaurants()\r\n            .then(restaurants => {\r\n                // Get all cuisines from all restaurants\r\n                const cuisines = restaurants.map((v, i) => restaurants[i].cuisine_type);\r\n                // Remove duplicates from cuisines\r\n                const uniqueCuisines = cuisines.filter((v, i) => cuisines.indexOf(v) == i);\r\n                return uniqueCuisines;\r\n            })\r\n    }\r\n\r\n    /**\r\n     * Restaurant page URL.\r\n     */\r\n    static urlForRestaurant(restaurant) {\r\n        return (`./restaurant.html?id=${restaurant.id}`);\r\n    }\r\n\r\n    /**\r\n     * Restaurant image URL.\r\n     */\r\n    static imageUrlForRestaurant(restaurant) {\r\n        return (`img/${restaurant.id}-600.jpg`);\r\n    }\r\n\r\n    /**\r\n     * Restaurant image srcset string.\r\n     */\r\n    static srcsetForRestaurant(restaurant) {\r\n        return (`img/webp/${restaurant.id}-400.webp 400w,\r\n      img/webp/${restaurant.id}-600.webp 600w,\r\n      img/webp/${restaurant.id}-800.webp 800w`);\r\n    }\r\n\r\n\r\n\r\n    /***** REVIEWS *****/\r\n\r\n    /**\r\n     * Update server with new review\r\n     * If offline, request background sync\r\n     * cache review locally\r\n     */\r\n    static submitReview(review) {\r\n        // if online submit review to server\r\n        DBHelper.postReviewtoServer(review)\r\n            .catch(() => {\r\n                console.log('submit review failed');\r\n                // if offline, send reviews to pending_reviews cache\r\n                DBHelper.submitPendingReviewtoDB(review);\r\n                DBHelper.sendSyncRequest('review-sync');\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Add reviews to the database\r\n     */\r\n    static addReviewsToDB(reviews) {\r\n        return DBHelper.createDatabase()\r\n            .then((db) => {\r\n                if (!db) {\r\n                    return;\r\n                }\r\n                const tx = db.transaction('reviews', 'readwrite');\r\n                const store = tx.objectStore('reviews');\r\n\r\n                return Promise.all(reviews.map(review => {\r\n                    console.log('adding reviews to database');\r\n                    return store.put(review);\r\n                }));\r\n\r\n            })\r\n            .catch((error) => {\r\n                tx.abort();\r\n                console.error(error);\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Fetch reviews from database\r\n     */\r\n    static fetchLocalReviewsById(id) {\r\n        console.log('fetchReviewsfromDB');\r\n        return DBHelper.createDatabase()\r\n            .then((db) => {\r\n                const tx = db.transaction('reviews', 'readonly');\r\n                const store = tx.objectStore('reviews');\r\n                const index = store.index('restaurant_id');\r\n                return index.getAll(id);\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Go to network to get reviews by restaurant id\r\n     */\r\n    static fetchReviewsByIdFromNetwork(id) {\r\n        console.log('fetch reviews from network');\r\n        return fetch(DBHelper.DATABASE_URL + `/reviews/?restaurant_id=${id}`)\r\n            .then(DBHelper.validateJSON)\r\n            .then(response => {\r\n                return response;\r\n            })\r\n\r\n    }\r\n\r\n    /**\r\n     * Fetch reviews from DB\r\n     * If no reviews, fetch from network\r\n     * add to database\r\n     */\r\n    static fetchReviewsById(id) {\r\n        return DBHelper.fetchLocalReviewsById(id)\r\n            .then(function(response) {\r\n\r\n                if (response.length === 0) {\r\n                    return DBHelper.fetchReviewsByIdFromNetwork(id)\r\n                        .then(response => {\r\n                            DBHelper.addReviewsToDB(response);\r\n                            return response;\r\n                        })\r\n                        .catch(DBHelper.logError);\r\n                }\r\n\r\n                return response;\r\n\r\n            })\r\n    }\r\n\r\n    /**\r\n     * Register a sync event\r\n     */\r\n    static sendSyncRequest(sync_tag) {\r\n        if (navigator.serviceWorker) {\r\n            navigator.serviceWorker.ready\r\n                .then(reg => reg.sync.register(sync_tag))\r\n                .then(() => console.log('Sync event registered'));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Submit review to server\r\n     */\r\n    static postReviewtoServer(review) {\r\n        const url = 'http://localhost:1337/reviews/';\r\n        console.log(url);\r\n        console.log(review);\r\n        const options = {\r\n            method: 'POST',\r\n            body: JSON.stringify(review)\r\n        }\r\n\r\n        return fetch(url, options);\r\n    }\r\n\r\n\r\n    /**\r\n     * If offline, send review to pending_review object store\r\n     */\r\n    static submitPendingReviewtoDB(review) {\r\n        console.log('submit pending review to pending_reviews');\r\n        return DBHelper.createDatabase()\r\n            .then((db) => {\r\n                if (!db) {\r\n                    return;\r\n                }\r\n                const tx = db.transaction('pending_reviews', 'readwrite');\r\n                const store = tx.objectStore('pending_reviews');\r\n\r\n                console.log(review);\r\n                console.log('adding review to pending_reviews');\r\n\r\n                store.put(review);\r\n\r\n                return tx.complete;\r\n            })\r\n    }\r\n\r\n    /**\r\n     * Update local database with new review\r\n     */\r\n    static submitSingleReviewtoDB(review) {\r\n        return DBHelper.createDatabase()\r\n            .then((db) => {\r\n                const tx = db.transaction('reviews', 'readwrite');\r\n                const store = tx.objectStore('reviews');\r\n                return store.put(review);\r\n            })\r\n            .catch(DBHelper.logError);\r\n    }\r\n\r\n    /**\r\n     * Fetch reviews from local database\r\n     * to send to server\r\n     */\r\n    static fetchPendingReviewsFromDB() {\r\n        return DBHelper.createDatabase()\r\n            .then(db => {\r\n                if (!db) {\r\n                    return;\r\n                }\r\n                const tx = db.transaction('pending_reviews', 'readonly');\r\n                const store = tx.objectStore('pending_reviews');\r\n                return store.getAll();\r\n            })\r\n            .then(responses => {\r\n\r\n                const reviews = responses || [];\r\n\r\n                console.log('reading reviews from pending_reviews');\r\n                console.log(reviews);\r\n\r\n                return Promise.all(reviews.map(review => {\r\n                    console.log('post each review to server');\r\n                    return DBHelper.postReviewtoServer(review);\r\n\r\n                }));\r\n            })\r\n            .then(DBHelper.clearPendingReviews)\r\n            .catch(error => console.log(error));\r\n    }\r\n\r\n    /**\r\n     * Clear pending reviews from local database\r\n     */\r\n    static clearPendingReviews() {\r\n        return DBHelper.createDatabase()\r\n            .then(db => {\r\n                if (!db) {\r\n                    return;\r\n                }\r\n                const tx = db.transaction('pending_reviews', 'readwrite');\r\n                const store = tx.objectStore('pending_reviews');\r\n                store.clear();\r\n                console.log('pending review store cleared');\r\n                return tx.complete;\r\n\r\n            })\r\n\r\n    }\r\n\r\n\r\n    /***** FAVORITE TOGGLE *****/\r\n\r\n    /**\r\n     * Update favourite status in client side database\r\n     */\r\n\r\n    static updateLocalFavouriteStatus(response) {\r\n        return DBHelper.createDatabase()\r\n            .then((db) => {\r\n                const tx = db.transaction('restaurants', 'readwrite');\r\n                const store = tx.objectStore('restaurants');\r\n                return store.put(response);\r\n            })\r\n    }\r\n\r\n    /**\r\n     * Update favourite status in client side database, independent of PUT request\r\n     */\r\n\r\n    static updateFavoriteStatusLocally(id, pressed) {\r\n        DBHelper.fetchFavouriteStatusLocally(id)\r\n            .then(response => {\r\n                console.log(response.is_favorite, 'old status from fetch');\r\n                const restaurant = response;\r\n                restaurant.is_favorite = pressed;\r\n                console.log(response.is_favorite, 'new status');\r\n\r\n                DBHelper.addFavoriteStatusLocally(restaurant);\r\n            })\r\n            .catch(DBHelper.logError)\r\n\r\n    }\r\n\r\n    static fetchFavouriteStatusLocally(id) {\r\n        return DBHelper.createDatabase()\r\n            .then((db) => {\r\n                const tx = db.transaction('restaurants', 'readonly');\r\n                const store = tx.objectStore('restaurants');\r\n                const selectedRestaurant = store.get(parseInt(id));\r\n                return selectedRestaurant;\r\n\r\n            })\r\n    }\r\n\r\n    static addFavoriteStatusLocally(restaurant) {\r\n        return DBHelper.createDatabase()\r\n            .then((db) => {\r\n                const tx = db.transaction('restaurants', 'readwrite');\r\n                const store = tx.objectStore('restaurants');\r\n                return store.put(restaurant);\r\n            })\r\n            .catch(DBHelper.logError);\r\n    }\r\n\r\n    /**\r\n     * Update favorite status.\r\n     */\r\n    static addFavoriteStatus(id, status) {\r\n        let url = (`http://localhost:1337/restaurants/${id}/?is_favorite=${status}`);\r\n\r\n        return fetch(url, {\r\n                method: 'PUT',\r\n            })\r\n            .catch(() => {\r\n                DBHelper.fetchFavouriteStatusLocally(id)\r\n                .then(res => {\r\n                    console.log(res, 'catch response');\r\n                    DBHelper.addPendingHeartStatus(res);\r\n                    console.log('pending heart status added')\r\n                })\r\n                .catch(DBHelper.logError);\r\n                DBHelper.sendSyncRequest('heart-sync');\r\n            })\r\n    }\r\n\r\n    static retryPostHeartStatus(id, status){\r\n        let url = (`http://localhost:1337/restaurants/${id}/?is_favorite=${status}`);\r\n\r\n        return fetch(url, {\r\n                method: 'PUT',\r\n            });\r\n    }\r\n\r\n    static addPendingHeartStatus(restaurant){\r\n        return DBHelper.createDatabase()\r\n            .then((db) => {\r\n                const tx = db.transaction('pending_heart', 'readwrite');\r\n                const store = tx.objectStore('pending_heart');\r\n                return store.put(restaurant);\r\n            })\r\n            .catch(DBHelper.logError);\r\n    }\r\n\r\n    static fetchPendingHeartStatus(){\r\n        return DBHelper.createDatabase()\r\n            .then((db) => {\r\n                const tx = db.transaction('pending_heart', 'readonly');\r\n                const store = tx.objectStore('pending_heart');\r\n                return store.getAll();\r\n            })\r\n            .then(res => {\r\n                const restaurants = res || [];\r\n\r\n                console.log('reading restaurants from pending_heart');\r\n                console.log(restaurants);\r\n\r\n                return Promise.all(restaurants.map(restaurant => {\r\n                    console.log('post each favourite status to server');\r\n                    return DBHelper.retryPostHeartStatus(restaurant.id, restaurant.is_favorite);\r\n\r\n                }));\r\n\r\n            })\r\n            .then(DBHelper.clearPendingHearts)\r\n            .catch(DBHelper.logError);\r\n    }\r\n\r\n    static clearPendingHearts() {\r\n        return DBHelper.createDatabase()\r\n            .then(db => {\r\n                if (!db) {\r\n                    return;\r\n                }\r\n                const tx = db.transaction('pending_heart', 'readwrite');\r\n                const store = tx.objectStore('pending_heart');\r\n                store.clear();\r\n                console.log('pending heart store cleared');\r\n                return tx.complete;\r\n\r\n            })\r\n\r\n    }\r\n\r\n\r\n    /**\r\n     * Click handler to update favourite button aria labels.\r\n     */\r\n    static toggleButtonState() {\r\n        document.addEventListener('click', DBHelper.updateButtonState, false);\r\n    }\r\n\r\n    /**\r\n     * Toggles aria labels and aria pressed state\r\n     */\r\n    static updateButtonState(e) {\r\n        const Id = e.target.dataset.action;\r\n\r\n        if (!Id) {\r\n\r\n            return;\r\n\r\n        } else {\r\n\r\n            if (e.target.dataset.action === 'save') {\r\n                let saveButton = e.target;\r\n                let restaurantId = saveButton.dataset.restaurantId;\r\n                console.log(restaurantId);\r\n                let currentState = saveButton.getAttribute('aria-pressed');\r\n                let pressed = 'true';\r\n                let labelText = 'Remove from favourites';\r\n\r\n\r\n                if (currentState === 'true') {\r\n                    pressed = 'false';\r\n                    labelText = 'Add to favourites';\r\n                }\r\n\r\n                saveButton.setAttribute('aria-pressed', pressed);\r\n                saveButton.setAttribute('aria-label', labelText);\r\n\r\n                //post data about restaurant to Server and IndexedDB\r\n                DBHelper.updateFavoriteStatusLocally(restaurantId, pressed);\r\n                DBHelper.addFavoriteStatus(restaurantId, pressed);\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n\r\n    /***** MAP TOGGLE *****/\r\n\r\n    /**\r\n     * Add map script to html\r\n     */\r\n    static addScript() {\r\n        const target = document.body;\r\n        const mapScript = document.createElement('script');\r\n        mapScript.src = 'https://maps.googleapis.com/maps/api/js?key=AIzaSyCSQXjgi1K6hqDS4W3nWVK_z0lntlbLFPo&libraries=places&callback=initMap';\r\n        target.appendChild(mapScript);\r\n    }\r\n\r\n    static toggleMap(anchorID, mapElemID) {\r\n        const anchor = document.getElementById(anchorID);\r\n        const mapFrame = document.getElementById(mapElemID);\r\n\r\n        anchor.addEventListener('click', (e) => {\r\n            // Prevent Default link behaviour\r\n            e.preventDefault();\r\n\r\n            // Check for map section\r\n            if (!mapFrame) return;\r\n\r\n            // Toggle map section visiblity\r\n            mapFrame.classList.toggle('is-visible');\r\n\r\n            // Fetch script only if it hasn't already been fetched\r\n            if (!window.google) {\r\n                DBHelper.addScript();\r\n            }\r\n\r\n        }, false);\r\n\r\n    }\r\n\r\n    /**\r\n     * Map marker for a restaurant.\r\n     */\r\n    static mapMarkerForRestaurant(restaurant, map) {\r\n        const marker = new google.maps.Marker({\r\n            position: restaurant.latlng,\r\n            title: restaurant.name,\r\n            url: DBHelper.urlForRestaurant(restaurant),\r\n            map: map,\r\n            animation: google.maps.Animation.DROP\r\n        });\r\n        return marker;\r\n    }\r\n\r\n}"]}